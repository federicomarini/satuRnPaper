### Load the benchmark datasets, which are output from 1_Gtex_prepare.Rmd
err <- try(library("here", character.only = TRUE), silent = TRUE)
if (class(err) == 'try-error') {
install.packages("here", repos = "https://cloud.r-project.org")
library("here", character.only = TRUE)
}
wd <- here()
wd
source(file=past0(wd,"/Performance_benchmarks/DTU_methods.R"))
source(file=paste0(wd,"/Performance_benchmarks/DTU_methods.R"))
if(TRUE) {
nrCores <- 2
if(nrCores != 1) {
doParallel <- TRUE
doProgress <- 'none'
library(doMC)
registerDoMC(cores = nrCores)
} else {
doParallel <- FALSE
doProgress <- 'text'
}
}
getwd()
### Load the benchmark datasets, which are output from 1_Gtex_prepare.Rmd
##load(file=paste0(wd,'/Data/Gtex_workingData/02_GTEx_benchmark_datasets_count.Rdata'))
load(file="/Users/jg/Desktop/paper_Data/Gtex_workingData/02_GTEx_benchmark_datasets_count.Rdata")
### Wrangle benchmark data
names(gtexBenchmarkDataLenient)   <- paste0(names(gtexBenchmarkDataLenient)  , '_filterLenient')
names(gtexBenchmarkDataStringent) <- paste0(names(gtexBenchmarkDataStringent), '_filterStringent')
gtexBenchmarkData <- c(
gtexBenchmarkDataLenient,
gtexBenchmarkDataStringent)
### Run DTU analysis on benchmark data
print("start satuRn")
tStart <- Sys.time()
suppressWarnings(gtexDtuBenchmark_quasiBinomial <- plyr::llply(
.data = gtexBenchmarkData,
.inform = TRUE,
.fun = function(localData) {
### Perform DTU analysis
t0 <- Sys.time()
localRes <- qbDTU_DTU(
countData  = localData$data,
tx2gene    = localData$metaInfo,
sampleData = localData$design
)
testTime <- as.numeric( difftime(Sys.time(), t0, units = 'secs') )
### Massage
localRes$gene_modified <- localData$metaInfo$gene_modified[match(
localRes$TXNAME, localData$metaInfo$TXNAME
)]
### Return result
return(
list(
dtuAnalysis = localRes,
runtime = testTime
)
)
}
))
# still called quasiBinomial
suppressWarnings(gtexDtuBenchmark_quasiBinomial <- plyr::llply(
.data = gtexBenchmarkData,
.inform = TRUE,
.fun = function(localData) {
### Perform DTU analysis
t0 <- Sys.time()
localRes <- satuRn_DTU(
countData  = localData$data,
tx2gene    = localData$metaInfo,
sampleData = localData$design
)
testTime <- as.numeric( difftime(Sys.time(), t0, units = 'secs') )
### Massage
localRes$gene_modified <- localData$metaInfo$gene_modified[match(
localRes$TXNAME, localData$metaInfo$TXNAME
)]
### Return result
return(
list(
dtuAnalysis = localRes,
runtime = testTime
)
)
}
))
file=paste0(wd,'/Data/Gtex_workingData/03_GTEx_DTU_results_count.Rdata'))
wd
rm(list=ls())
gc()
getwd()
gtexCm <- fread("/Users/jg/Desktop/paper_Data/Gtex_workingData/01_GTEx_baseline_dataset_count.gz", data.table = FALSE)
library(data.table)
library(edgeR)
library(DRIMSeq)
gtexCm <- fread("/Users/jg/Desktop/paper_Data/Gtex_workingData/01_GTEx_baseline_dataset_count.gz", data.table = FALSE)
#gtexCm <- fread("/Users/jg/Desktop/paper_Data/Gtex_workingData/01_GTEx_baseline_dataset_count.gz", data.table = FALSE)
gtexSample <- fread("Users/jg/Desktop/paper_Data/Gtex_workingData/01_GTEx_baseline_metadata.txt", data.table = FALSE)
#gtexCm <- fread("/Users/jg/Desktop/paper_Data/Gtex_workingData/01_GTEx_baseline_dataset_count.gz", data.table = FALSE)
gtexSample <- fread("/Users/jg/Desktop/paper_Data/Gtex_workingData/01_GTEx_baseline_metadata.txt", data.table = FALSE)
# Extract gene info
txInfo <- gtexCm[,c('transcript_id','gene_id')]
colnames(txInfo)[1] <- 'isoform_id'
rownames(gtexCm) <- txInfo$isoform_id
# Extract samples
gtexSample <- gtexSample[
which(gtexSample$SMTSD == 'Adrenal Gland'),
]
# specifically filter on extraction kit
gtexSample <- gtexSample[
which(gtexSample$SMNABTCHT == 'RNA Extraction from Paxgene-derived Lysate Plate Based'),
]
# specifically filter on SMAFRZE
gtexSample <- gtexSample[
which(gtexSample$SMAFRZE == 'RNASEQ'),
]
# specifically filter on center
gtexSample <- gtexSample[
which(gtexSample$SMCENTER == 'B1'),
]
gtexCm <- gtexCm[,which(
colnames(gtexCm) %in% gtexSample$SAMPID
)]
# Set benchmark parameters
samplesPrCondition   <- c(5,20,50)
nrRepsMade           <- 3
fracGenesAffected    <- 0.15
nrCoresToUse         <- 2
# Set up parallel processing
if(nrCoresToUse != 1) {
doParallel <- TRUE
doProgress <- 'none'
library(doMC)
registerDoMC(cores = nrCoresToUse)
} else {
doParallel <- FALSE
doProgress <- 'text'
}
# list for looping
nrRepList <- split(
rep(
x = samplesPrCondition,
times = nrRepsMade
),
paste0(
'samples_used_',
rep(
x = samplesPrCondition,
times = nrRepsMade
),
'_rep_',
sort( rep(
x = 1:nrRepsMade,
times = length(samplesPrCondition)
) )
)
)
# Sanity check
length(nrRepList) == length(samplesPrCondition) * nrRepsMade
table(sapply(nrRepList, length))
gtexBenchmarkDataLenient <- lapply(c(1:length(nrRepList)), function(x) {
# Step 1: Extract random sub-sample of correct size
set.seed(x)
localSampleSize <- nrRepList[[x]]
if(TRUE) {
localSubset <- sample(
colnames(gtexCm),
localSampleSize * 2
)
localDesign <- data.frame(
sample_id = localSubset,
condition = c(
rep('a',floor  ( length(localSampleSize) )),
rep('b',ceiling( length(localSampleSize) ))
),
stringsAsFactors = FALSE
)
localDesign <- localDesign[sort.list(localDesign$condition),]
}
# Step 2: Subset to expressed features using edgeR::filterByExpr
if(TRUE) {
y <- edgeR::DGEList(counts = gtexCm[,localDesign$sample_id])
design <- model.matrix(~condition, data=localDesign)
filter <- edgeR::filterByExpr(y,design=design)
localCm <- y$counts[filter,]
# Get only multi-isoform genes (after filtering)
localTx <- txInfo[which(
txInfo$isoform_id %in% rownames(localCm)),]
tmp <- table(localTx$gene_id)
tmp <- tmp[which( tmp >= 2)]
localTx <- localTx[which(localTx$gene_id %in% names(tmp)),]
localCm <- localCm[which(rownames(localCm) %in% localTx$isoform_id),]
}
# Step 3: Extract isoforms to modify
if(TRUE) {
genesToModify <- sample(
x = unique(localTx$gene_id),
size = round(
length(unique(localTx$gene_id)) * fracGenesAffected
)
)
samplesToModify <- localDesign$sample_id[which(
localDesign$condition == 'b')]
cm_swapped <- localCm
transcripts_toSwap_current <- c()
transcripts_swapped_current <- c()
transcripts_swapped_all <- c()
transcripts_toSwap_all <- c()
for (gene in genesToModify) {
current <- localTx[which(localTx$gene_id==gene),]
nSwap <- max(2,rbinom(1,nrow(current),1/3))
transcripts_toSwap_current <- sample(
x = current$isoform_id,
size = nSwap)
# swap order of txs completely by putting the fist one last
transcripts_swapped_current <- c(transcripts_toSwap_current[-1],transcripts_toSwap_current[1])
# Add to swapping queue
transcripts_swapped_all <- c(transcripts_swapped_all,transcripts_swapped_current)
transcripts_toSwap_all <- c(transcripts_toSwap_all,transcripts_toSwap_current)
}
# Perform the swapping in matrix
cm_swapped[transcripts_toSwap_all,which(colnames(cm_swapped)%in%samplesToModify)] <- cm_swapped[transcripts_swapped_all,which(colnames(cm_swapped)%in%samplesToModify)]
# Set swapping in localTx
localTx$txSwapped <- vector(length=nrow(localTx))
localTx[which(localTx$isoform_id %in% transcripts_swapped_all),"txSwapped"] <- TRUE
localTx$nrSamplesPerCondition <- localSampleSize
}
colnames(localTx) <- c('TXNAME','GENEID','txSwapped','nrSamplesPerCondition')
# Combine data
dataList <- list(
data     = cm_swapped,
design   = localDesign,
metaInfo = localTx
)
return(dataList)
})
names(gtexBenchmarkDataLenient) <- paste0(names(nrRepList),"_filterLenient")
gtexBenchmarkDataStringent <- lapply(c(1:length(nrRepList)), function(x) {
# Step 1: Extract random sub-sample of correct size
set.seed(x)
localSampleSize <- nrRepList[[x]]
if(TRUE) {
localSubset <- sample(
colnames(gtexCm),
localSampleSize * 2
)
localDesign <- data.frame(
sample_id = localSubset,
condition = c(
rep('a',floor  ( length(localSampleSize) )),
rep('b',ceiling( length(localSampleSize) ))
),
stringsAsFactors = FALSE
)
localDesign <- localDesign[sort.list(localDesign$condition),]
}
# Step 2: Subset to expressed features using DRIMSeq::dmFilter
if(TRUE) {
localCm <- gtexCm[,localDesign$sample_id]
geneForEachTx <- txInfo[match(rownames(localCm),txInfo[,"isoform_id"]),"gene_id"]
localCm$gene_id <- geneForEachTx
localCm$feature_id <- row.names(localCm)
d <- DRIMSeq::dmDSdata(counts = localCm, samples = localDesign)
d_filter <- dmFilter(d,
min_samps_feature_expr=localSampleSize/2,
min_feature_expr=10,
min_samps_feature_prop=localSampleSize/2,
min_feature_prop=0.1,
min_samps_gene_expr=localSampleSize,
min_gene_expr=10)
localCm <- gtexCm[counts(d_filter)$feature_id,localDesign$sample_id]
# Get only multi-isoform genes (after filtering)
localTx <- txInfo[which(
txInfo$isoform_id %in% rownames(localCm)),]
tmp <- table(localTx$gene_id)
tmp <- tmp[which( tmp >= 2)]
localTx <- localTx[which(localTx$gene_id %in% names(tmp)),]
localCm <- localCm[which(rownames(localCm) %in% localTx$isoform_id),]
}
# Step 3: Extract isoforms to modify
if(TRUE) {
genesToModify <- sample(
x = unique(localTx$gene_id),
size = round(length(unique(localTx$gene_id)) * fracGenesAffected))
samplesToModify <- localDesign$sample_id[which(
localDesign$condition == 'b')]
cm_swapped <- localCm
transcripts_toSwap_current <- c()
transcripts_swapped_current <- c()
transcripts_swapped_all <- c()
transcripts_toSwap_all <- c()
for (gene in genesToModify) {
current <- localTx[which(localTx$gene_id==gene),]
nSwap <- max(2,rbinom(1,nrow(current),1/3))
transcripts_toSwap_current <- sample(
x = current$isoform_id,
size = nSwap)
# swap order of txs completely by putting the fist one last
transcripts_swapped_current <- c(transcripts_toSwap_current[-1],transcripts_toSwap_current[1])
# Add to swapping queue
transcripts_swapped_all <- c(transcripts_swapped_all,transcripts_swapped_current)
transcripts_toSwap_all <- c(transcripts_toSwap_all,transcripts_toSwap_current)
}
# Perform the swapping in matrix
cm_swapped[transcripts_toSwap_all,which(colnames(cm_swapped)%in%samplesToModify)] <- cm_swapped[transcripts_swapped_all,which(colnames(cm_swapped)%in%samplesToModify)]
# Set swapping in localTx
localTx$txSwapped <- vector(length=nrow(localTx))
localTx[which(localTx$isoform_id %in% transcripts_swapped_all),"txSwapped"] <- TRUE
localTx$nrSamplesPerCondition <- localSampleSize
}
colnames(localTx) <- c('TXNAME','GENEID','txSwapped','nrSamplesPerCondition')
# Combine data
dataList <- list(
data     = cm_swapped,
design   = localDesign,
metaInfo = localTx
)
return(dataList)
})
names(gtexBenchmarkDataStringent) <- paste0(names(nrRepList),"_filterStringent")
save(gtexBenchmarkDataLenient, gtexBenchmarkDataStringent, file=paste0(wd,'/Data/Gtex_workingData/02_GTEx_benchmark_datasets_count.Rdata'))
err <- try(library("here", character.only = TRUE), silent = TRUE)
if (class(err) == 'try-error') {
install.packages("here", repos = "https://cloud.r-project.org")
library("here", character.only = TRUE)
}
wd <- here()
save(gtexBenchmarkDataLenient, gtexBenchmarkDataStringent, file=paste0(wd,'/Data/Gtex_workingData/02_GTEx_benchmark_datasets_count.Rdata'))
wd,'/Data/Gtex_workingData/02_GTEx_benchmark_datasets_count.Rdata'
wd
save(gtexBenchmarkDataLenient, gtexBenchmarkDataStringent, file=paste0(wd,'/Data/Gtex_workingData/02_GTEx_benchmark_datasets_count.Rdata'))
rm(list=ls())
gc()
err <- try(library("here", character.only = TRUE), silent = TRUE)
if (class(err) == 'try-error') {
install.packages("here", repos = "https://cloud.r-project.org")
library("here", character.only = TRUE)
}
wd <- here()
setwd(wd)
source(file=paste0(wd,"/Performance_benchmarks/DTU_methods.R"))
err <- try(library("here", character.only = TRUE), silent = TRUE)
if (class(err) == 'try-error') {
install.packages("here", repos = "https://cloud.r-project.org")
library("here", character.only = TRUE)
}
wd <- here()
source(file=paste0(wd,"/Performance_benchmarks/DTU_methods.R"))
if(TRUE) {
nrCores <- 2
if(nrCores != 1) {
doParallel <- TRUE
doProgress <- 'none'
library(doMC)
registerDoMC(cores = nrCores)
} else {
doParallel <- FALSE
doProgress <- 'text'
}
}
### Load the benchmark datasets, which are output from 1_Gtex_prepare.Rmd
load(file=paste0(wd,'/Data/Gtex_workingData/02_GTEx_benchmark_datasets_count.Rdata'))
## Wrangle benchmark data
names(gtexBenchmarkDataLenient)   <- paste0(names(gtexBenchmarkDataLenient)  , '_filterLenient')
names(gtexBenchmarkDataStringent) <- paste0(names(gtexBenchmarkDataStringent), '_filterStringent')
gtexBenchmarkData <- c(
gtexBenchmarkDataLenient,
gtexBenchmarkDataStringent)
### Run DTU analysis on benchmark data
print("start satuRn")
tStart <- Sys.time()
suppressWarnings(gtexDtuBenchmark_satuRn <- plyr::llply(
.data = gtexBenchmarkData,
.inform = TRUE,
.fun = function(localData) {
### Perform DTU analysis
t0 <- Sys.time()
localRes <- satuRn_DTU(
countData  = localData$data,
tx2gene    = localData$metaInfo,
sampleData = localData$design
)
testTime <- as.numeric( difftime(Sys.time(), t0, units = 'secs') )
### Massage
localRes$gene_modified <- localData$metaInfo$gene_modified[match(
localRes$TXNAME, localData$metaInfo$TXNAME
)]
### Return result
return(
list(
dtuAnalysis = localRes,
runtime = testTime
)
)
}
))
tStart <- Sys.time()
difftime(Sys.time(), tStart)
tStart <- Sys.time()
library(tidyverse)
library(iCOBRA)
err <- try(library("here", character.only = TRUE), silent = TRUE)
if (class(err) == 'try-error') {
install.packages("here", repos = "https://cloud.r-project.org")
library("here", character.only = TRUE)
}
wd <- here()
rm(list=ls())
gc()
# Set benchmark parameters
samplesPrCondition   <- c(5,20,50)
nrRepsMade           <- 3
fracGenesAffected    <- 0.15
nrCoresToUse         <- 2
# Set up parallel processing
if(nrCoresToUse != 1) {
doParallel <- TRUE
doProgress <- 'none'
library(doMC)
registerDoMC(cores = nrCoresToUse)
} else {
doParallel <- FALSE
doProgress <- 'text'
}
# list for looping
nrRepList <- split(
rep(
x = samplesPrCondition,
times = nrRepsMade
),
paste0(
'samples_used_',
rep(
x = samplesPrCondition,
times = nrRepsMade
),
'_rep_',
sort( rep(
x = 1:nrRepsMade,
times = length(samplesPrCondition)
) )
)
)
# Sanity check
length(nrRepList) == length(samplesPrCondition) * nrRepsMade
table(sapply(nrRepList, length))
nrRepList
gtexCm <- fread("/Users/jg/Desktop/paper_Data/Gtex_workingData/01_GTEx_baseline_dataset_count.gz", data.table = FALSE)
rm(list=ls())
gc()
